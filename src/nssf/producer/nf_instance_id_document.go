/*
 * NSSF NSSAI Availability
 *
 * NSSF NSSAI Availability Service
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package producer

import (
	"net/http"

	"free5gc/lib/http_wrapper"
	. "free5gc/lib/openapi/models"
	"free5gc/src/nssf/handler/message"
	"free5gc/src/nssf/logger"
	. "free5gc/src/nssf/plugin"
)

// NSSAIAvailabilityDelete - Deletes an already existing S-NSSAIs per TA provided by the NF service consumer (e.g AMF)
func NSSAIAvailabilityDelete(responseChan chan message.HandlerResponseMessage, nfId string) {

	logger.Nssaiavailability.Infof("Request received - NSSAIAvailabilityDelete")

	var (
		status         int
		problemDetails ProblemDetails
	)

	status = nssaiavailabilityDelete(nfId, &problemDetails)

	if status == http.StatusNoContent {
		responseChan <- message.HandlerResponseMessage{
			HttpResponse: &http_wrapper.Response{
				Header: nil,
				Status: status,
			},
		}
	} else {
		responseChan <- message.HandlerResponseMessage{
			HttpResponse: &http_wrapper.Response{
				Header: nil,
				Status: status,
				Body:   problemDetails,
			},
		}
	}
}

// NSSAIAvailabilityPatch - Updates an already existing S-NSSAIs per TA provided by the NF service consumer (e.g AMF)
func NSSAIAvailabilityPatch(responseChan chan message.HandlerResponseMessage, nfId string, patchDoc PatchDocument) {

	logger.Nssaiavailability.Infof("Request received - NSSAIAvailabilityPatch")

	var (
		isValidRequest                  bool = true
		status                          int
		authorizedNssaiAvailabilityInfo AuthorizedNssaiAvailabilityInfo
		problemDetails                  ProblemDetails
	)

	// TODO: Request NfProfile of NfId from NRF
	//       Check if NfId is valid AMF and obtain AMF Set ID
	//       If NfId is invalid, return ProblemDetails with code 404 Not Found
	//       If NF consumer is not authorized to update NSSAI availability, return ProblemDetails with code 403 Forbidden

	if isValidRequest {
		status = nssaiavailabilityPatch(nfId, patchDoc, &authorizedNssaiAvailabilityInfo, &problemDetails)
	}

	if status == http.StatusOK {
		responseChan <- message.HandlerResponseMessage{
			HttpResponse: &http_wrapper.Response{
				Header: nil,
				Status: status,
				Body:   authorizedNssaiAvailabilityInfo,
			},
		}
	} else {
		responseChan <- message.HandlerResponseMessage{
			HttpResponse: &http_wrapper.Response{
				Header: nil,
				Status: status,
				Body:   problemDetails,
			},
		}
	}
}

// NSSAIAvailabilityPut - Updates/replaces the NSSF with the S-NSSAIs the NF service consumer (e.g AMF) supports per TA
func NSSAIAvailabilityPut(responseChan chan message.HandlerResponseMessage, nfId string, nssaiAvailabilityInfo NssaiAvailabilityInfo) {

	logger.Nssaiavailability.Infof("Request received - NSSAIAvailabilityPut")

	var (
		isValidRequest                  bool = true
		status                          int
		authorizedNssaiAvailabilityInfo AuthorizedNssaiAvailabilityInfo
		problemDetails                  ProblemDetails
	)

	// TODO: Request NfProfile of NfId from NRF
	//       Check if NfId is valid AMF and obtain AMF Set ID
	//       If NfId is invalid, return ProblemDetails with code 404 Not Found
	//       If NF consumer is not authorized to update NSSAI availability, return ProblemDetails with code 403 Forbidden

	if isValidRequest {
		status = nssaiavailabilityPut(nfId, nssaiAvailabilityInfo, &authorizedNssaiAvailabilityInfo, &problemDetails)
	}

	if status == http.StatusOK {
		responseChan <- message.HandlerResponseMessage{
			HttpResponse: &http_wrapper.Response{
				Header: nil,
				Status: status,
				Body:   authorizedNssaiAvailabilityInfo,
			},
		}
	} else {
		responseChan <- message.HandlerResponseMessage{
			HttpResponse: &http_wrapper.Response{
				Header: nil,
				Status: status,
				Body:   problemDetails,
			},
		}
	}
}
