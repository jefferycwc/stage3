/*
 * NSSF NS Selection
 *
 * NSSF Network Slice Selection Service
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package producer

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"free5gc/lib/http_wrapper"
	. "free5gc/lib/openapi/models"
	"free5gc/src/nssf/handler/message"
	"free5gc/src/nssf/logger"
	"free5gc/src/nssf/plugin"
	"free5gc/src/nssf/util"
)

// Parse NSSelectionGet query parameter
func parseQueryParameter(query url.Values) (param plugin.NsselectionQueryParameter, err error) {

	if query.Get("nf-type") != "" {
		param.NfType = new(NfType)
		*param.NfType = NfType(query.Get("nf-type"))
	}

	param.NfId = query.Get("nf-id")

	if query.Get("slice-info-request-for-registration") != "" {
		param.SliceInfoRequestForRegistration = new(SliceInfoForRegistration)
		err = json.NewDecoder(strings.NewReader(query.Get("slice-info-request-for-registration"))).Decode(param.SliceInfoRequestForRegistration)
		if err != nil {
			return
		}
	}

	if query.Get("slice-info-request-for-pdu-session") != "" {
		param.SliceInfoRequestForPduSession = new(SliceInfoForPduSession)
		err = json.NewDecoder(strings.NewReader(query.Get("slice-info-request-for-pdu-session"))).Decode(param.SliceInfoRequestForPduSession)
		if err != nil {
			return
		}
	}

	if query.Get("home-plmn-id") != "" {
		param.HomePlmnId = new(PlmnId)
		err = json.NewDecoder(strings.NewReader(query.Get("home-plmn-id"))).Decode(param.HomePlmnId)
		if err != nil {
			return
		}
	}

	if query.Get("tai") != "" {
		param.Tai = new(Tai)
		err = json.NewDecoder(strings.NewReader(query.Get("tai"))).Decode(param.Tai)
		if err != nil {
			return
		}
	}

	if query.Get("supported-features") != "" {
		param.SupportedFeatures = query.Get("supported-features")
	}

	return
}

// Check if the NF service consumer is authorized
// TODO: Check if the NF service consumer is legal with local configuration, or possibly after querying NRF through
//       `nf-id` e.g. Whether the V-NSSF is authorized
func checkNfServiceConsumer(nfType NfType) error {
	if nfType != NfType_AMF && nfType != NfType_NSSF {
		return fmt.Errorf("`nf-type`:'%s' is not authorized to retrieve the slice selection information", string(nfType))
	}

	return nil
}

// NSSelectionGet - Retrieve the Network Slice Selection Information
func NSSelectionGet(responseChan chan message.HandlerResponseMessage, query url.Values) {

	logger.Nsselection.Infof("Request received - NSSelectionGet")

	var (
		isValidRequest             bool = true
		status                     int
		authorizedNetworkSliceInfo AuthorizedNetworkSliceInfo
		problemDetails             ProblemDetails
	)

	// TODO: Record request times of the NF service consumer and response with ProblemDetails of 429 Too Many Requests
	//       if the consumer has sent too many requests in a configured amount of time
	// TODO: Check URI length and response with ProblemDetails of 414 URI Too Long if URI is too long

	// Parse query parameter
	param, err := parseQueryParameter(query)
	if err != nil {
		status = http.StatusBadRequest
		problemDetails = ProblemDetails{
			Title:  util.MALFORMED_REQUEST,
			Status: http.StatusBadRequest,
			Detail: "[Query Parameter] " + err.Error(),
		}
		isValidRequest = false
	}

	// Check permission of NF service consumer
	err = checkNfServiceConsumer(*param.NfType)
	if err != nil {
		status = http.StatusForbidden
		problemDetails = ProblemDetails{
			Title:  util.UNAUTHORIZED_CONSUMER,
			Status: http.StatusForbidden,
			Detail: err.Error(),
		}
		isValidRequest = false
	}

	if isValidRequest {
		if param.SliceInfoRequestForRegistration != nil {
			// Network slice information is requested during the Registration procedure
			status = nsselectionForRegistration(param, &authorizedNetworkSliceInfo, &problemDetails)
		} else {
			// Network slice information is requested during the PDU session establishment procedure
			status = nsselectionForPduSession(param, &authorizedNetworkSliceInfo, &problemDetails)
		}
	}

	if status == http.StatusOK {
		responseChan <- message.HandlerResponseMessage{
			HttpResponse: &http_wrapper.Response{
				Header: nil,
				Status: status,
				Body:   authorizedNetworkSliceInfo,
			},
		}
	} else {
		responseChan <- message.HandlerResponseMessage{
			HttpResponse: &http_wrapper.Response{
				Header: nil,
				Status: status,
				Body:   problemDetails,
			},
		}
	}
}
